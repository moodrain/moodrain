<?php
namespace Muyu\Support;

use Muyu\Support\Traits\MuyuExceptionTrait;

class DbBuilder
{
/*
$builder = new DbBuilder('database.local');
$builder->input([
    'db' => 'db_test',
    'tablePrefix' => 'tb_',
    'tables' => [
        'test' => [
            ['id', 'int', ['primary', 'increment']],
            ['name', 'varchar', ['unique']],
            ['created_at', 'datetime'],
        ],
    ],
])->build();
*/
    private $type;
    private $host;
    private $user;
    private $pass;
    private $db;
    private $charset;
    private $collate;
    private $pdo;
    private $pdoAttr;
    private $autoMakeTable;
    private $tables;
    private $tablePrefix;

    use MuyuExceptionTrait;
    public function __construct($muyuConfig = 'database.default', $init = true) {
        $this->initError();
        if($init)
            $this->init(conf($muyuConfig));
    }
    function init($config = [], $connect = true) {
        $this->charset = 'utf8mb4';
        $this->collate = 'utf8mb4_general_ci';
        $this->tables = [];
        $this->autoMakeTable = false;
        $this->tablePrefix = '';
        foreach($config as $key => $val)
            $this->$key = $val;
        if(!$connect)
            return $this;
        $conf = [
            'type' => $this->type,
            'host' => $this->host,
            'user' => $this->user,
            'pass' => $this->pass,
            'db'   => $this->db,
        ];
        if($this->db) {
            $confTmp = $conf;
            $confTmp['db'] = '';
            $this->pdo = Tool::pdo('', $confTmp, $this->pdoAttr);
            $stmt = $this->pdo->query('SHOW DATABASES');
            $rs = $stmt->fetchAll(\PDO::FETCH_NUM);
            $dbs = [];
            foreach($rs as $db)
                $dbs[] = $db[0];
            if(in_array($this->db, $dbs))
                $this->pdo->exec('USE ' . $this->db);
        }
        else
            $this->pdo = Tool::pdo('', $conf, $this->pdoAttr);
        return $this;
    }
    function pdoAttr($attr = null) {
        if(!$attr)
            return $this->pdoAttr;
        $this->pdoAttr = $attr;
        return $this;
    }
    function db($db = null) {
        if(!$db)
            return $this->db;
        $this->db = $db;
        return $this;
    }
    function autoMakeTable($auto = null) {
        if(!$auto)
            return $this->autoMakeTable;
        $this->autoMakeTable = $auto;
        return $this;
    }
    function charset() {
        return $this->charset;
    }
    function collate() {
        return $this->collate;
    }
    function tablePrefix($prefix = null) {
        if(!$prefix)
            return $this->tablePrefix;
        $this->tablePrefix = $prefix;
        return $this;
    }
    function createDb($db = null, $use = true, $charset = 'utf8mb4', $collate = 'utf8mb4_general_ci') {
        $db = $db ?? $this->db ?? null;
        if(!$db) {
            $this->addError(1, 'db name not set');
            return false;
        }
        $this->pdo->exec('CREATE DATABASE IF NOT EXISTS ' . $db . ' DEFAULT CHARSET ' . $charset . ' COLLATE ' . $collate. ';');
        if($use)
            $this->pdo->exec('USE ' . $db);
        return $this;
    }
    function dropDb($db = null) {
        $dbName = $db ?? $this->db;
        if(!$dbName) {
            $this->addError(1, 'db name not set');
            return false;
        }
        $this->pdo->exec('DROP DATABASE IF EXISTS ' . $dbName);
        return $this;
    }
    function json() {
        $db = new \stdClass();
        $db->db = $this->db;
        $db->tablePrefx = $this->tablePrefix;
        $db->tables = $this->tables;
        return json_encode($db, 128 | 256);
    }
    function sql() {
        $sql = '# Generated by Moodrain DbBuilder, see https://github.com/moodrain/moodrain for more information' . PHP_EOL;
        $sql .= $this->db ? 'CREATE DATABASE IF NOT EXISTS ' . $this->db . ' DEFAULT CHARSET ' . $this->charset . ' COLLATE ' . $this->collate. ';' . PHP_EOL . 'USE ' . $this->db . ';' . PHP_EOL : '';
        foreach($this->tables as $tableName => $table)
            $sql .= $this->TableBuilder($tableName, $table, $this->tablePrefix, false, false)->sql() . PHP_EOL;
        return $sql;
    }
    function bean($package = 'main.entity', $dir = 'bean') {
        !file_exists($dir) && mkdir($dir);
        foreach($this->tables as $tableName => $table)
            file_put_contents($dir . '/' . ucfirst(Tool::hump(str_replace($this->tablePrefix, '', $tableName . '.java'))), $this->TableBuilder($tableName, $table, $this->tablePrefix, false, false)->bean($package)) ;
        return $this;
    }
    function save($name = null,$mode = null) {
        $filename = $name ?? $this->db . '.json' ?? time() . '.json';
        if(!$mode) {
            $ext = Tool::ext($filename);
            $mode = $ext == 'json' || $ext == 'sql' ? $ext : 'json';
        }
        if($mode != 'json' && $mode != 'sql') {
            $this->addError(2, 'unsupported mode');
            return false;
        }
        $content = $mode == 'json' ? $this->json() : $this->sql();
        file_put_contents($filename, $content);
    }
    function read($file = null) {
        $filename = $file ?? $this->db . '.json';
        if(!file_exists($filename)) {
            $this->addError(3, 'file not found');
            return false;
        }
        $this->input(json_decode(file_get_contents($filename), true));
        return $this;
    }
    function input($db) {
        if(!$db) {
            $this->addError(4, 'parse json fail');
            return false;
        }
        $this->db = $db['db'];
        $this->tablePrefix = $db['tablePrefix'];
        $this->tables = $db['tables'];
        return $this;
    }
    function build() {
        $this->createDb();
        foreach($this->tables as $tableName => $table)
            $this->TableBuilder($tableName, $table, $this->tablePrefix, true, false);
        return $this;
    }
    function TableBuilder($table = '', $fields = [], $prefix = '', $build = null, $addToTables = true) {
        $addToTables && $this->tables[$table] = $fields;
        $build === null && $build = $this->autoMakeTable;
        $class =  new class($this->pdo, $table, $fields, $prefix) {
            private $pdo;
            private $table;
            private $fields;
            private $primaryKey;
            private $prefix;
            function __construct($pdo, $table = '', $fields = [], $prefix = '') {
                $this->pdo = $pdo;
                $this->table = $table;
                $this->prefix = $prefix;
                foreach($fields as $field)
                    $this->addField($field[0], $field[1] , $field[2] ?? []);
            }
            function table($table = null) {
                if(!$table)
                    return $this->table;
                $this->table = $table;
                return $this;
            }
            function primaryKey() {
                return $this->primaryKey;
            }
            function prefix($prefix = null) {
                if(!$prefix)
                    return $this->prefix;
                $this->prefix = $prefix;
                return $this;
            }
            function addField($name, $type, $attr = []) {
                $theAttr = [];
                foreach($attr as $a) {
                    $a == 'primary' && $this->primaryKey = $name;
                    $a == 'increment' && $theAttr['increment'] = 'AUTO_INCREMENT';
                    $a == 'null' && $theAttr['null'] = 'NULL';
                    $a == 'notnull' && $theAttr['null'] = 'NOT NULL';
                    $a == 'unique' && $theAttr['unique'] = 'UNIQUE';
                }
                $theAttr['null'] = $theAttr['null'] ?? 'NOT NULL';
                $type = $type == 'varchar' ? 'varchar(255)' : $type;
                $this->fields[] = ['name' => $name, 'type' => $type, 'attr' => $theAttr];
            }
            function make() {
                $sql = $this->sql();
                $this->pdo->exec($sql);
            }
            function sql() {
                $sql = 'CREATE TABLE `' . $this->prefix . $this->table . '` (';
                foreach($this->fields as $f) {
                    $sql .= '`' . $f['name'] . '` ' . $f['type'];
                    $sql .= $f['attr'] ? ' ' . implode(' ', $f['attr']) : '';
                    $sql .= ', ';
                }
                $sql .= 'PRIMARY KEY (`' . $this->primaryKey . '`));';
                return $sql;
            }
            function bean($package = 'main.entity') {
                $sql = '';
                $package = 'package ' . $package . ';' . PHP_EOL;
                $class =  PHP_EOL . 'public class ' . ucfirst(Tool::hump($this->table)) . PHP_EOL . '{' . PHP_EOL;
                foreach($this->fields as $f)
                    $sql .= '   ' . 'private ' . $this->toJavaType($f['type']) . ' ' . Tool::hump($f['name']) . ';' . PHP_EOL;
                $sql .= PHP_EOL;
                foreach($this->fields as $f) {
                    $sql .= '   public ' . $this->toJavaType($f['type']) . ' ' . 'get' . ucfirst(Tool::hump($f['name'])) . '() { return ' . Tool::hump($f['name']) . '; }' . PHP_EOL;
                    $sql .= '   public void set' . ucfirst(Tool::hump($f['name'])) . '(' . $this->toJavaType($f['type']) . ' ' . Tool::hump($f['name']) . ') { this.' . Tool::hump($f['name']) . ' = ' . Tool::hump($f['name']) . '; }' . PHP_EOL;
                }
                $sql = $package . $class . $sql . '}';
                return $sql;
            }
            private function toJavaType($type) {
                if(strpos($type, 'varchar') !== false)
                    return 'String';
                if(strpos($type, 'text') !== false)
                    return 'String';
                if(strpos($type, 'int') !== false)
                    return 'Integer';
                switch($type) {
                    case 'float':    return 'Float';
                    case 'date':     return 'java.sql.Date';
                    case 'time':     return 'java.sql.Time';
                    case 'datetime': return 'java.sql.Timestamp';
                    default:         return 'Object';
                }
            }
        };
        if($build) {
            $class->make();
            return $this;
        }
        return $class;
    }
}